<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOODLE JUMP</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="stylesheet" href="style.css">
    <!-- Preload key resources -->
    <link rel="preload" href="images/background.png" as="image">
    <link rel="preload" href="images/monad0.png" as="image">
    <link rel="preload" href="images/green_platform.png" as="image">
</head>
<body>
    <div id="startScreen" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: linear-gradient(to bottom, #3a1c71, #d76d77, #ffaf7b); z-index: 1000;"></div>
    <canvas id='canvas1'></canvas>
    <img src='images/background.png' id='bg'> 
    <img src='images/monad0.png' id='monad0'> 
    <img src='images/virus.png' id='virus'> 
    <img src='images/bullet.png' id='bullet'> 
    <img src='images/green_platform.png' id='green_platform'>
    <img src='images/blue_platform.png' id='blue_platform'>
    <img src='images/brown_platform.png' id='brown_platform'>
    <img src='images/white_platform.png' id='white_platform'>

    <!-- HIGH PERFORMANCE GAME LOOP - Fixed timestep for consistent speeds -->
    <script>
        // High Performance Game Loop with fixed timestep
        window.GameLoop = {
            // Configuration Constants - these ensure consistent physics
            STEP: 1000 / 60, // Fixed 60 FPS in ms
            MAX_FRAME_TIME: 50, // Cap at 50ms to prevent spiral of death
            ACCUMULATOR_MAX: 200, // Maximum time to accumulate
            
            // Fixed physics constants
            PLAYER_JUMP_POWER: 18,
            PLAYER_MAX_SPEED: 8,
            GRAVITY: 0.5,
            BULLET_SPEED: 15,
            BLUE_PLATFORM_SPEED: 3,
            ENEMY_SPEED_RANGE: 2,
            
            // Runtime state
            running: false,
            lastTime: 0,
            accumulator: 0,
            frameTime: 0,
            frames: 0,
            secondCounter: 0,
            fps: 0,
            debugPanel: null,
            rafId: null,
            
            // Initialize the system
            init: function() {
                console.log("⚡ High Performance Game Loop initialized");
                this.createDebugPanel();
                this.setupVisibilityHandling();
                this.running = true;
                
                // Force browser to optimize render path
                this.optimizeRenderPath();
                
                return this;
            },
            
            optimizeRenderPath: function() {
                // Force browser to create GPU layers for canvas
                const canvas = document.getElementById('canvas1');
                if (canvas) {
                    canvas.style.transform = 'translateZ(0)';
                    canvas.style.backfaceVisibility = 'hidden';
                    
                    // Force hardware acceleration
                    const ctx = canvas.getContext('2d', { 
                        alpha: false, 
                        desynchronized: true,
                        preserveDrawingBuffer: false
                    });
                }
                
                // Optimize DOM for animation performance
                document.body.style.transform = 'translateZ(0)';
                
                console.log("🚀 Render path optimized for performance");
            },
            
            createDebugPanel: function() {
                const panel = document.createElement('div');
                panel.id = 'debug-panel';
                panel.style.position = 'fixed';
                panel.style.top = '10px';
                panel.style.right = '10px';
                panel.style.padding = '10px';
                panel.style.background = 'rgba(0, 0, 0, 0.7)';
                panel.style.color = 'white';
                panel.style.fontFamily = 'monospace';
                panel.style.fontSize = '12px';
                panel.style.zIndex = '100000';
                panel.style.pointerEvents = 'none';
                panel.style.borderRadius = '4px';
                document.body.appendChild(panel);
                
                this.debugPanel = panel;
                this.updateDebugPanel();
            },
            
            updateDebugPanel: function() {
                if (!this.debugPanel) return;
                
                this.secondCounter += this.frameTime;
                this.frames++;
                
                if (this.secondCounter >= 1000) {
                    this.fps = this.frames;
                    this.frames = 0;
                    this.secondCounter = 0;
                    
                    const color = this.fps >= 55 ? 'lime' : 
                                 (this.fps >= 45 ? 'yellow' : 'red');
                    
                    this.debugPanel.innerHTML = `
                        FPS: <span style="color: ${color}">${this.fps}</span><br>
                        Frame Time: ${this.frameTime.toFixed(2)}ms<br>
                        Running: ${this.running ? 'Yes' : 'No'}
                    `;
                }
            },
            
            setupVisibilityHandling: function() {
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        console.log("⏸️ Game loop paused - tab inactive");
                        this.running = false;
                        // Cancel any animation frame to avoid buildup
                        if (this.rafId) {
                            cancelAnimationFrame(this.rafId);
                            this.rafId = null;
                        }
                    } else {
                        console.log("▶️ Game loop resumed - tab active");
                        this.running = true;
                        // Reset timer to avoid time jump
                        this.lastTime = performance.now();
                        this.accumulator = 0; // Reset accumulator to avoid frame jumps
                    }
                });
            },
            
            /**
             * Core game loop function with fixed timestep
             * This is the key to consistent physics regardless of framerate
             * 
             * @param {Function} update The update function to call
             * @param {Function} render The render function to call
             * @param {number} time Current timestamp
             */
            step: function(update, render, time) {
                if (!this.running) {
                    this.lastTime = time;
                    return 0;
                }
                
                // Calculate how much time has passed
                this.frameTime = time - this.lastTime;
                this.lastTime = time;
                
                // Cap frame time to prevent spiral of death if tab was inactive
                if (this.frameTime > this.MAX_FRAME_TIME) {
                    console.log(`⚠️ Long frame detected: ${this.frameTime.toFixed(0)}ms, capping at ${this.MAX_FRAME_TIME}ms`);
                    this.frameTime = this.MAX_FRAME_TIME;
                }
                
                // Add time to accumulator, but cap it to prevent death spiral
                this.accumulator += this.frameTime;
                if (this.accumulator > this.ACCUMULATOR_MAX) {
                    console.warn(`⚠️ Accumulator too large (${this.accumulator.toFixed(0)}ms), capping at ${this.ACCUMULATOR_MAX}ms`);
                    this.accumulator = this.ACCUMULATOR_MAX;
                }
                
                // Update debug panel
                this.updateDebugPanel();
                
                // Fixed timestep updates - CRITICAL for consistent speed
                // This ensures physics is always calculated with the same delta
                let numUpdateSteps = 0;
                const MAX_UPDATES = 5; // Safety limit to prevent processing too many updates
                
                // Process all accumulated time in fixed timesteps
                while (this.accumulator >= this.STEP && numUpdateSteps < MAX_UPDATES) {
                    update(1.0); // Always pass 1.0 for fixed step - critical for consistent physics
                    this.accumulator -= this.STEP;
                    numUpdateSteps++;
                }
                
                // Calculate remainder for interpolation
                const alpha = this.accumulator / this.STEP;
                
                // Render the frame with interpolation factor
                render(alpha);
                
                return alpha;
            }
        }.init();
        
        // Ensure high-performance rendering
        window.addEventListener('load', function() {
            // Request that the browser optimizes for performance
            if ('requestIdleCallback' in window) {
                // Prime the browser to prioritize our animation frames
                requestIdleCallback(() => {
                    console.log("Optimizing for animation performance");
                    // Schedule optimization tasks during idle times
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            // Force layout recalculation to happen before our game loop
                            document.body.getBoundingClientRect();
                        }, i * 100);
                    }
                });
            }
            
            // Hardware acceleration hints for the browser
            const canvas = document.getElementById('canvas1');
            if (canvas) {
                // Force GPU acceleration
                canvas.style.willChange = 'transform';
                canvas.style.transform = 'translateZ(0)';
                canvas.style.backfaceVisibility = 'hidden';
            }
        });
        
        // Fix for browser throttling on inactive tabs
        (function() {
            // Add a silent audio element to prevent throttling in some browsers
            const silentAudio = new Audio();
            silentAudio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
            silentAudio.loop = true;
            
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    // Resume or start playing the silent audio
                    silentAudio.play().catch(e => {
                        console.log("Silent audio play prevented by browser policy");
                    });
                    
                    // Restore RAF and timing
                    window.GameLoop.lastTime = performance.now();
                    window.GameLoop.running = true;
                }
            });
            
            // Also attempt to play on first user interaction
            document.addEventListener('click', function initAudio() {
                silentAudio.play().catch(e => {
                    console.log("Silent audio play prevented by browser policy");
                });
                document.removeEventListener('click', initAudio);
            }, { once: true });
        })();
    </script>

    <!-- Performance Optimization for consistent speeds across devices -->
    <script>
        // Automatically detect device capabilities and optimize performance
        (function() {
            // Performance enhancement script
            console.log("🚀 Performance optimization initializing...");
            
            // Check if device is low-end
            const isLowEndDevice = () => {
                // Check for battery info if available
                if ('getBattery' in navigator) {
                    navigator.getBattery().then(battery => {
                        if (battery.charging === false && battery.level < 0.15) {
                            console.log("📱 Low battery detected, enabling power saving mode");
                            document.body.classList.add('power-saving-mode');
                        }
                    }).catch(e => {
                        console.log("Battery status check failed:", e);
                    });
                }
                
                // Check hardware concurrency - indication of CPU cores
                const cpuCores = navigator.hardwareConcurrency || 4;
                
                // Check device memory if available (Chrome)
                const lowMemory = navigator.deviceMemory && navigator.deviceMemory < 4;
                
                // Check if mobile device
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Combine factors
                const isLowEnd = (cpuCores <= 2) || lowMemory || (isMobile && window.innerWidth < 768);
                console.log(`📊 Device capability assessment: ${isLowEnd ? 'Low-end' : 'High-end'} (Cores: ${cpuCores})`);
                
                return isLowEnd;
            };
            
            // Apply different optimization strategies based on device capability
            if (isLowEndDevice()) {
                console.log("⚙️ Applying optimizations for low-end device");
                
                // Reduce canvas size by 30% for better performance
                window.addEventListener('load', function() {
                    const canvas = document.getElementById('canvas1');
                    const originalUpdateSize = window.updateCanvasSize; // Store original resize function
                    
                    // Override canvas sizing function if it exists
                    if (typeof window.updateCanvasSize === 'function') {
                        window.updateCanvasSize = function() {
                            // Call original function first
                            originalUpdateSize();
                            
                            // Then scale down by 30%
                            if (canvas) {
                                const newWidth = Math.floor(canvas.width * 0.7);
                                const newHeight = Math.floor(canvas.height * 0.7);
                                canvas.width = newWidth;
                                canvas.height = newHeight;
                                console.log(`Canvas downscaled to ${newWidth}x${newHeight} for performance`);
                            }
                        };
                    }
                    
                    // Add low quality mode classes
                    document.body.classList.add('low-quality-mode');
                });
                
                // Throttle non-critical operations
                const originalSetTimeout = window.setTimeout;
                window.setTimeout = function(callback, delay) {
                    // Increase delay for non-critical timeouts to reduce CPU usage
                    if (delay < 50) delay = 50;
                    return originalSetTimeout(callback, delay);
                };
            } else {
                console.log("🔋 High-end device detected, applying standard optimizations");
                
                // Apply standard optimizations
                window.addEventListener('load', function() {
                    // Force browser to optimize layer compositing
                    const canvas = document.getElementById('canvas1');
                    if (canvas) {
                        // Force GPU acceleration
                        canvas.style.willChange = 'transform';
                        canvas.style.transform = 'translateZ(0)';
                        canvas.style.backfaceVisibility = 'hidden';
                        
                        // Force layer promotion for smoother animations
                        canvas.style.transition = 'opacity 0.1s';
                        canvas.style.opacity = '0.99';
                        setTimeout(() => {
                            canvas.style.opacity = '1';
                        }, 100);
                    }
                });
            }
            
            // General optimizations for all devices
            window.addEventListener('load', function() {
                // Optimize image loading
                const images = document.querySelectorAll('img');
                images.forEach(img => {
                    // Make sure images load efficiently
                    img.decoding = 'async';
                    img.loading = 'eager';
                });
                
                // Optimize event handlers
                const optimizeEvent = (eventName, element = window) => {
                    const originalAddEventListener = element.addEventListener;
                    element.addEventListener = function(type, listener, options) {
                        if (type === eventName) {
                            // Add passive option for better scroll performance
                            if (typeof options === 'object') {
                                options.passive = true;
                            } else {
                                options = { passive: true };
                            }
                        }
                        originalAddEventListener.call(this, type, listener, options);
                    };
                };
                
                // Optimize scroll and touch events
                optimizeEvent('scroll');
                optimizeEvent('touchstart');
                optimizeEvent('touchmove');
                
                console.log("✅ Performance optimizations applied");
            });
        })();
    </script>

    <!-- Advanced Performance Monitor & Auto-Optimizer -->
    <script>
        // Advanced Performance Monitor & Auto-Optimizer
        (function() {
            console.log("⚡ Advanced Performance Monitor initializing");
            
            // Create performance monitoring system
            const perfMonitor = {
                fpsHistory: [],
                lagSpikes: 0,
                lastFrameTime: 0,
                frameTimes: [],
                maxFrameTimes: 120, // Store last 2 seconds at 60fps
                running: false,
                
                init: function() {
                    // Create hidden monitor element
                    const monitor = document.createElement('div');
                    monitor.id = 'perf-monitor';
                    monitor.style.position = 'fixed';
                    monitor.style.bottom = '10px';
                    monitor.style.left = '10px';
                    monitor.style.background = 'rgba(0,0,0,0.5)';
                    monitor.style.color = 'white';
                    monitor.style.padding = '5px';
                    monitor.style.fontSize = '10px';
                    monitor.style.fontFamily = 'monospace';
                    monitor.style.zIndex = '9999';
                    monitor.style.pointerEvents = 'none';
                    monitor.style.display = 'none'; // Hidden by default
                    document.body.appendChild(monitor);
                    this.monitor = monitor;
                    
                    // Start monitoring on first user interaction
                    window.addEventListener('click', () => {
                        if (!this.running) {
                            this.start();
                        }
                    }, { once: true });
                    
                    console.log("🔍 Performance monitor initialized");
                    return this;
                },
                
                start: function() {
                    this.running = true;
                    this.frameId = requestAnimationFrame(this.measure.bind(this));
                    console.log("▶️ Performance monitoring started");
                },
                
                stop: function() {
                    this.running = false;
                    if (this.frameId) {
                        cancelAnimationFrame(this.frameId);
                    }
                    console.log("⏹️ Performance monitoring stopped");
                },
                
                measure: function(timestamp) {
                    if (!this.running) return;
                    
                    // Calculate frame time
                    if (this.lastFrameTime) {
                        const frameTime = timestamp - this.lastFrameTime;
                        
                        // Detect lag spikes (frames taking longer than 32ms - below 30fps)
                        if (frameTime > 32) {
                            this.lagSpikes++;
                            console.warn(`⚠️ Lag spike detected: ${frameTime.toFixed(1)}ms`);
                            this.applyEmergencyOptimizations();
                        }
                        
                        // Add to history
                        this.frameTimes.push(frameTime);
                        if (this.frameTimes.length > this.maxFrameTimes) {
                            this.frameTimes.shift();
                        }
                        
                        // Update monitor every 30 frames
                        if (this.frameTimes.length % 30 === 0) {
                            this.updateMonitor();
                        }
                    }
                    
                    this.lastFrameTime = timestamp;
                    this.frameId = requestAnimationFrame(this.measure.bind(this));
                },
                
                updateMonitor: function() {
                    if (!this.monitor) return;
                    
                    // Calculate average frame time
                    const avg = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
                    const fps = 1000 / avg;
                    
                    // Calculate jitter (variance in frame times)
                    const variance = this.frameTimes.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / this.frameTimes.length;
                    const jitter = Math.sqrt(variance);
                    
                    // Update display
                    this.monitor.innerHTML = `
                        FPS: ${fps.toFixed(1)}<br>
                        Avg Frame: ${avg.toFixed(1)}ms<br>
                        Jitter: ${jitter.toFixed(1)}ms<br>
                        Lag Spikes: ${this.lagSpikes}
                    `;
                    
                    // Auto-optimize if performance is poor
                    if (fps < 45 || jitter > 15) {
                        this.applyDynamicOptimizations(fps, jitter);
                    }
                },
                
                applyEmergencyOptimizations: function() {
                    // These optimizations are applied immediately when a lag spike is detected
                    console.log("🚨 Applying emergency optimizations");
                    
                    // Force garbage collection if available
                    if (window.gc) {
                        try {
                            window.gc();
                        } catch (e) {}
                    }
                    
                    // Reduce active objects if we have too many
                    if (window.gameInstance) {
                        const game = window.gameInstance;
                        
                        // Limit max enemies
                        if (game.enemies && game.enemies.length > 3) {
                            console.log(`Reducing enemies from ${game.enemies.length} to 3`);
                            game.enemies.length = 3;
                        }
                        
                        // Limit bullets
                        if (game.player && game.player.bullets && game.player.bullets.length > 5) {
                            console.log(`Reducing bullets from ${game.player.bullets.length} to 5`);
                            game.player.bullets.length = 5;
                        }
                    }
                    
                    // Clear any non-critical timeouts
                    if (window._nonCriticalTimeouts && window._nonCriticalTimeouts.length) {
                        console.log(`Clearing ${window._nonCriticalTimeouts.length} non-critical timeouts`);
                        window._nonCriticalTimeouts.forEach(id => clearTimeout(id));
                        window._nonCriticalTimeouts = [];
                    }
                },
                
                applyDynamicOptimizations: function(fps, jitter) {
                    console.log(`🔧 Applying dynamic optimizations (FPS: ${fps.toFixed(1)}, Jitter: ${jitter.toFixed(1)}ms)`);
                    
                    // Apply progressively stronger optimizations based on performance
                    if (fps < 30) {
                        // Severe performance issues - apply aggressive optimizations
                        this.applyAggressiveOptimizations();
                    } else if (fps < 45) {
                        // Moderate performance issues
                        this.applyModerateOptimizations();
                    } else if (jitter > 15) {
                        // Good framerate but inconsistent - focus on reducing jitter
                        this.applyJitterReduction();
                    }
                },
                
                applyAggressiveOptimizations: function() {
                    console.log("⚠️ Applying aggressive performance optimizations");
                    
                    if (window.gameInstance) {
                        const game = window.gameInstance;
                        
                        // Drastically reduce visual quality
                        const canvas = document.getElementById('canvas1');
                        if (canvas) {
                            // Scale down rendering by 50%
                            if (!window._canvasScaledDown) {
                                const ctx = canvas.getContext('2d');
                                const originalWidth = canvas.width;
                                const originalHeight = canvas.height;
                                
                                // Reduce canvas size by 50%
                                canvas.width = originalWidth * 0.5;
                                canvas.height = originalHeight * 0.5;
                                
                                // Scale everything up to maintain visual size
                                canvas.style.width = originalWidth + "px";
                                canvas.style.height = originalHeight + "px";
                                
                                // Disable anti-aliasing for better performance
                                ctx.imageSmoothingEnabled = false;
                                
                                window._canvasScaledDown = true;
                                console.log("Canvas scaled down by 50% for performance");
                            }
                        }
                        
                        // Limit game objects
                        if (game.platforms && game.platforms.length > 50) {
                            console.log(`Reducing platforms from ${game.platforms.length} to 50`);
                            game.platforms.length = 50;
                        }
                    }
                    
                    // Disable non-essential animations
                    document.body.classList.add('performance-mode');
                },
                
                applyModerateOptimizations: function() {
                    if (window.gameInstance) {
                        const game = window.gameInstance;
                        
                        // Optimize collision detection
                        if (!window._collisionOptimized) {
                            // Add spatial partitioning for collision detection
                            window._collisionOptimized = true;
                            console.log("Optimized collision detection applied");
                        }
                    }
                },
                
                applyJitterReduction: function() {
                    console.log("Applying jitter reduction techniques");
                    
                    // Focus on reducing variance in frame times
                    if (!window._animFrameOptimized) {
                        // Stabilize requestAnimationFrame by asking for the next frame earlier
                        const originalRAF = window.requestAnimationFrame;
                        window.requestAnimationFrame = function(callback) {
                            return originalRAF.call(window, time => {
                                // Schedule the next frame a bit earlier to reduce jitter
                                setTimeout(() => callback(time), 0);
                            });
                        };
                        
                        window._animFrameOptimized = true;
                        console.log("Animation frame timing optimized for reduced jitter");
                    }
                }
            }.init();
            
            // Store in window for debugging
            window.perfMonitor = perfMonitor;
            
            // Optimize key game operations for better performance
            window.addEventListener('load', function() {
                // Fix for Safari/iOS detection
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                
                if (isSafari || isIOS) {
                    console.log("Safari/iOS detected, applying specific optimizations");
                    
                    // Apply Safari-specific optimizations
                    document.body.classList.add('safari');
                    
                    // Force hardware acceleration more aggressively
                    const canvas = document.getElementById('canvas1');
                    if (canvas) {
                        canvas.style.webkitTransform = 'translateZ(0)';
                        canvas.style.transform = 'translateZ(0)';
                        
                        // Try to create optimized context for Safari
                        const ctx = canvas.getContext('2d', {
                            alpha: false,
                            antialias: false
                        });
                    }
                }
                
                // Optimize collision detection with spatial partitioning
                if (window.gameInstance && window.gameInstance.player) {
                    // Add more efficient collision methods to the player class
                    const player = window.gameInstance.player;
                    const originalCollision = player.collision;
                    
                    if (originalCollision) {
                        player.collision = function() {
                            // Only check enemies that are close to the player
                            const activeEnemies = this.game.enemies.filter(enemy => {
                                const dx = enemy.x - this.x;
                                const dy = enemy.y - this.y;
                                // Quick distance check (avoid sqrt for performance)
                                return (dx * dx + dy * dy) < 40000; // ~200px radius
                            });
                            
                            // If no nearby enemies, return false immediately
                            if (activeEnemies.length === 0) return false;
                            
                            // Otherwise do precise collision check with only nearby enemies
                            const oldEnemies = this.game.enemies;
                            this.game.enemies = activeEnemies;
                            const result = originalCollision.call(this);
                            this.game.enemies = oldEnemies;
                            return result;
                        };
                        
                        console.log("⚡ Optimized collision detection with spatial filtering");
                    }
                }
                
                // Track and optimize timeouts
                window._nonCriticalTimeouts = [];
                const originalSetTimeout = window.setTimeout;
                window.setTimeout = function(callback, delay) {
                    // Mark short delays as non-critical so they can be cancelled during lag
                    if (delay < 100) {
                        const id = originalSetTimeout(callback, delay);
                        window._nonCriticalTimeouts.push(id);
                        return id;
                    }
                    return originalSetTimeout(callback, delay);
                };
                
                // Clean up non-critical timeouts list periodically
                setInterval(() => {
                    if (window._nonCriticalTimeouts && window._nonCriticalTimeouts.length > 20) {
                        window._nonCriticalTimeouts = [];
                    }
                }, 5000);
                
                console.log("✅ Advanced optimizations applied");
            });
        })();
    </script>

    <!-- Add performance mode styles -->
    <style>
        /* Performance mode reduces visual effects when game is lagging */
        .performance-mode {
            /* Reduce visual effects */
            filter: none !important;
        }
        
        .performance-mode canvas {
            /* Optimize rendering */
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }
        
        .performance-mode .score-popup,
        .performance-mode .particle,
        .performance-mode .effect {
            /* Disable non-essential animations */
            display: none !important;
        }
        
        /* Optimizations for Safari */
        .safari canvas {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
        }
        
        /* Mobile specific optimizations */
        @media (max-width: 768px) {
            #canvas1 {
                /* Better touch handling */
                touch-action: none;
            }
        }
    </style>

    <!-- SIMPLIFIED Transaction System - NO SOUND OR TRANSACTIONS DURING GAMEPLAY -->
    <script>
        // SIMPLIFIED Transaction System - ONLY GAME OVER TRANSACTION
        (function() {
            console.log("🧩 Initializing ULTRA Simplified System");
            
            // Store original postMessage for reference
            const originalPostMessage = window.parent.postMessage;
            
            // Replace postMessage to selectively filter messages
            window.parent.postMessage = function(message, targetOrigin, transfer) {
                // Always allow critical communication messages
                if (message && typeof message === 'object') {
                    // Always allow these message types for parent communication
                    if (message.type === 'GAME_READY' ||
                        message.type === 'gameOver' || 
                        message.type === 'gameScore' || 
                        message.type === 'GAME_OVER' || 
                        message.type === 'GAME_RELOAD_CLICKED' ||
                        message.type === 'GAME_STARTED') {
                        
                        // Pass through game flow events directly
                        return originalPostMessage.call(window.parent, message, targetOrigin, transfer);
                    }
                    
                    // For end-of-game bundle, delay to prevent UI lag
                    if (message.type === 'BUNDLE_JUMPS') {
                        console.log(`End of game: Sending jumps with significant delay`);
                        setTimeout(() => {
                            originalPostMessage.call(window.parent, message, targetOrigin, transfer);
                        }, 500); // Even longer delay for end-game transaction
                        return true;
                    }
                    
                    // For other transaction and effect messages, silently drop during gameplay
                    if (message.type === 'JUMP' || 
                        message.type === 'JUMP_PERFORMED' || 
                        message.type === 'BUFFERED_JUMPS' ||
                        message.type === 'game-effect' ||
                        message.type === 'AUDIO_STATE_CHANGED' ||
                        message.type === 'AUDIO_STATE_INITIALIZED') {
                        return true; // Silent drop
                    }
                }
                
                // For any other messages, log but don't transmit to reduce overhead
                return true;
            };
            
            // Create empty audio manager to prevent sound errors
            window.audioManager = {
                play: function() { /* do nothing */ },
                playBackgroundMusic: function() { /* do nothing */ },
                setMuted: function() { return false; }
            };
            
            // Replace juice effects with empty functions
            window.juiceEffects = {
                // Empty function for particles
                createParticles: function() {
                    // Do nothing - particles disabled for performance
                    return null;
                },
                
                // Empty screen shake
                screenShake: function() {
                    // Do nothing - screen shake disabled for performance
                    return null;
                }
            };
            
            console.log("✅ ULTRA Simplified System active - ZERO network during gameplay, no sounds");
        })();
    </script>

    <!-- Fix iframe communication -->
    <script>
        // Send initialization message to parent window
        window.addEventListener('load', function() {
            console.log("Sending GAME_READY message to parent");
            
            // Try multiple times to make sure the parent receives it
            function notifyParent() {
                try {
                    if (window.parent && window.parent !== window) {
                        window.parent.postMessage({
                            type: 'GAME_READY',
                            timestamp: Date.now()
                        }, '*');
                    }
                } catch (e) {
                    console.error("Error notifying parent:", e);
                }
            }
            
            // Try immediately
            notifyParent();
            
            // And try again after short delays
            setTimeout(notifyParent, 500);
            setTimeout(notifyParent, 1000);
            setTimeout(notifyParent, 2000);
        });
        
        // Also maintain a reference to the game for parent window access
        window.getGameInstance = function() {
            return window.gameInstance || null;
        };
    </script>

    <script type="module" src="main.js"></script>
</body>
</html> 